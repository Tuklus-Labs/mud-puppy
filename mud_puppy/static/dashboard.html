<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MUD-PUPPY MONITOR</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

:root {
    --bg: #0a0e1a;
    --panel-bg: #0d1420;
    --grid: #1a2a3a;
    --border: #1a3a4a;
    --green: #39ff14;
    --cyan: #00ffff;
    --amber: #ffd700;
    --magenta: #ff00ff;
    --red: #ff3333;
    --text: #e0e0e0;
    --dim: #607080;
}

html, body {
    width: 100%;
    height: 100%;
    background: var(--bg);
    color: var(--text);
    font-family: 'Share Tech Mono', 'JetBrains Mono', 'Fira Code', monospace;
    font-size: 13px;
    overflow-x: hidden;
}

/* CRT scanline overlay */
body::after {
    content: '';
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 9999;
    background: repeating-linear-gradient(
        0deg,
        transparent 0px,
        transparent 2px,
        rgba(0,0,0,0.08) 2px,
        rgba(0,0,0,0.08) 4px
    );
}

/* ---- HEADER ---- */
.header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 16px;
    border-bottom: 1px solid var(--border);
    background: var(--panel-bg);
}

.header-title {
    font-size: 18px;
    letter-spacing: 4px;
    color: var(--cyan);
    text-transform: uppercase;
    text-shadow: 0 0 10px rgba(0,255,255,0.4);
}

.header-right {
    display: flex;
    align-items: center;
    gap: 16px;
    font-size: 12px;
    color: var(--dim);
    text-transform: uppercase;
}

.header-right span { letter-spacing: 1px; }

.status-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: var(--red);
    display: inline-block;
    flex-shrink: 0;
}

.status-dot.connected {
    background: var(--green);
    box-shadow: 0 0 6px var(--green);
}

.status-dot.reconnecting {
    background: var(--amber);
    box-shadow: 0 0 6px var(--amber);
    animation: pulse 1s ease-in-out infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
}

/* ---- STATS BAR ---- */
.stats-bar {
    display: grid;
    grid-template-columns: repeat(6, 1fr);
    border-bottom: 1px solid var(--border);
    background: var(--panel-bg);
}

.stat-cell {
    padding: 6px 12px;
    border-right: 1px solid var(--border);
    text-align: center;
}

.stat-cell:last-child { border-right: none; }

.stat-label {
    font-size: 10px;
    color: var(--dim);
    text-transform: uppercase;
    letter-spacing: 2px;
    margin-bottom: 2px;
}

.stat-value {
    font-size: 22px;
    color: var(--text);
    letter-spacing: 1px;
}

.stat-value.loss-down { color: var(--green); text-shadow: 0 0 6px rgba(57,255,20,0.4); }
.stat-value.loss-up { color: var(--red); text-shadow: 0 0 6px rgba(255,51,51,0.4); }

/* ---- MAIN GRID ---- */
.main-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: auto auto auto auto auto;
    gap: 0;
    flex: 1;
}

.panel {
    background: var(--panel-bg);
    border: 1px solid var(--border);
    margin: -0.5px;
    display: flex;
    flex-direction: column;
    min-height: 0;
}

.panel-label {
    font-size: 10px;
    color: var(--dim);
    text-transform: uppercase;
    letter-spacing: 2px;
    padding: 6px 10px 2px 10px;
    flex-shrink: 0;
}

.panel-body {
    flex: 1;
    position: relative;
    min-height: 140px;
}

.panel-body canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
}

/* ---- GPU ROW ---- */
.gpu-row {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    grid-column: 1 / -1;
}

.gpu-cell {
    background: var(--panel-bg);
    border: 1px solid var(--border);
    margin: -0.5px;
    padding: 6px 10px;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 120px;
}

.gpu-cell .panel-label { padding: 0 0 4px 0; }

.gpu-cell canvas {
    width: 100%;
    max-width: 140px;
    height: 80px;
}

.gpu-value {
    font-size: 14px;
    color: var(--text);
    margin-top: 2px;
}

/* ---- BOTTOM ROW ---- */
.bottom-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-column: 1 / -1;
}

.token-panel, .lora-panel {
    background: var(--panel-bg);
    border: 1px solid var(--border);
    margin: -0.5px;
    padding: 6px 10px;
    min-height: 100px;
}

.token-stats {
    display: flex;
    gap: 20px;
    margin-top: 4px;
    font-size: 12px;
    color: var(--dim);
}

.token-stats span strong {
    color: var(--text);
}

.sparkline-wrap {
    height: 40px;
    position: relative;
    margin-top: 4px;
}

.sparkline-wrap canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
}

.lora-body {
    height: 80px;
    position: relative;
    margin-top: 4px;
}

.lora-body canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
}

/* ---- FOOTER ---- */
.footer {
    padding: 6px 16px;
    border-top: 1px solid var(--border);
    background: var(--panel-bg);
    font-size: 11px;
    color: var(--dim);
    letter-spacing: 1px;
    text-transform: uppercase;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.footer strong { color: var(--text); }

/* ---- AWAITING DATA ---- */
.awaiting {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 11px;
    color: var(--dim);
    text-transform: uppercase;
    letter-spacing: 3px;
    pointer-events: none;
}

/* ---- COMPLETION BANNER ---- */
.complete-overlay {
    position: fixed;
    inset: 0;
    background: rgba(10,14,26,0.85);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9000;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.4s;
}

.complete-overlay.visible {
    opacity: 1;
    pointer-events: auto;
}

.complete-banner {
    border: 2px solid var(--green);
    background: var(--panel-bg);
    padding: 32px 48px;
    text-align: center;
    box-shadow: 0 0 40px rgba(57,255,20,0.2), inset 0 0 40px rgba(57,255,20,0.05);
}

.complete-banner h1 {
    font-family: 'Share Tech Mono', monospace;
    font-size: 28px;
    color: var(--green);
    text-shadow: 0 0 20px rgba(57,255,20,0.6);
    letter-spacing: 6px;
    text-transform: uppercase;
    margin-bottom: 16px;
}

.complete-banner p {
    font-size: 14px;
    color: var(--text);
    letter-spacing: 1px;
}

/* ---- LAYOUT WRAPPER ---- */
.app {
    display: flex;
    flex-direction: column;
    height: 100vh;
}

.app > .main-grid { flex: 1; overflow: hidden; }

/* ---- RESPONSIVE ---- */
@media (max-width: 700px) {
    .stats-bar { grid-template-columns: repeat(3, 1fr); }
    .main-grid { grid-template-columns: 1fr; }
    .gpu-row { grid-template-columns: repeat(2, 1fr); }
    .bottom-row { grid-template-columns: 1fr; }
}
</style>
</head>
<body>
<div class="app">

<!-- HEADER -->
<div class="header">
    <div class="header-title">MUD-PUPPY MONITOR</div>
    <div class="header-right">
        <span id="hd-method">--</span>
        <span id="hd-model">--</span>
        <span class="status-dot" id="status-dot"></span>
    </div>
</div>

<!-- STATS BAR -->
<div class="stats-bar">
    <div class="stat-cell">
        <div class="stat-label">STEP</div>
        <div class="stat-value" id="st-step">--</div>
    </div>
    <div class="stat-cell">
        <div class="stat-label">EPOCH</div>
        <div class="stat-value" id="st-epoch">--</div>
    </div>
    <div class="stat-cell">
        <div class="stat-label">LOSS</div>
        <div class="stat-value" id="st-loss">--</div>
    </div>
    <div class="stat-cell">
        <div class="stat-label">LR</div>
        <div class="stat-value" id="st-lr">--</div>
    </div>
    <div class="stat-cell">
        <div class="stat-label">GRAD NORM</div>
        <div class="stat-value" id="st-grad">--</div>
    </div>
    <div class="stat-cell">
        <div class="stat-label">ETA</div>
        <div class="stat-value" id="st-eta">--</div>
    </div>
</div>

<!-- MAIN CHARTS GRID -->
<div class="main-grid">

    <!-- Row 1: Loss + LR -->
    <div class="panel">
        <div class="panel-label">LOSS CURVE</div>
        <div class="panel-body">
            <canvas id="chart-loss"></canvas>
            <div class="awaiting" id="aw-loss">AWAITING DATA</div>
        </div>
    </div>
    <div class="panel">
        <div class="panel-label">LEARNING RATE</div>
        <div class="panel-body">
            <canvas id="chart-lr"></canvas>
            <div class="awaiting" id="aw-lr">AWAITING DATA</div>
        </div>
    </div>

    <!-- Row 2: Grad Norm + Eval Loss -->
    <div class="panel">
        <div class="panel-label">GRADIENT NORM</div>
        <div class="panel-body">
            <canvas id="chart-grad"></canvas>
            <div class="awaiting" id="aw-grad">AWAITING DATA</div>
        </div>
    </div>
    <div class="panel">
        <div class="panel-label">EVAL LOSS</div>
        <div class="panel-body">
            <canvas id="chart-eval"></canvas>
            <div class="awaiting" id="aw-eval">AWAITING DATA</div>
        </div>
    </div>

    <!-- Row 3: GPU gauges -->
    <div class="gpu-row">
        <div class="gpu-cell">
            <div class="panel-label">VRAM</div>
            <canvas id="gauge-vram"></canvas>
            <div class="gpu-value" id="gv-vram">-- / -- GB</div>
        </div>
        <div class="gpu-cell">
            <div class="panel-label">GPU UTIL</div>
            <canvas id="gauge-util"></canvas>
            <div class="gpu-value" id="gv-util">--%</div>
        </div>
        <div class="gpu-cell">
            <div class="panel-label">TEMP</div>
            <canvas id="gauge-temp"></canvas>
            <div class="gpu-value" id="gv-temp">--C</div>
        </div>
        <div class="gpu-cell">
            <div class="panel-label">POWER</div>
            <canvas id="gauge-power"></canvas>
            <div class="gpu-value" id="gv-power">--W</div>
        </div>
    </div>

    <!-- Row 4: Token throughput + LoRA norms -->
    <div class="bottom-row">
        <div class="token-panel">
            <div class="panel-label">TOKEN THROUGHPUT</div>
            <div class="sparkline-wrap">
                <canvas id="chart-tps"></canvas>
            </div>
            <div class="token-stats">
                <span>TOK/S: <strong id="ts-tps">--</strong></span>
                <span>PAD: <strong id="ts-pad">--%</strong></span>
                <span>SEQ: <strong id="ts-seq">--</strong></span>
            </div>
        </div>
        <div class="lora-panel">
            <div class="panel-label">LORA WEIGHT NORMS</div>
            <div class="lora-body">
                <canvas id="chart-lora"></canvas>
                <div class="awaiting" id="aw-lora">AWAITING DATA</div>
            </div>
        </div>
    </div>
</div>

<!-- FOOTER -->
<div class="footer" id="footer">
    MODEL: <strong>--</strong> | METHOD: <strong>--</strong> | PRECISION: <strong>--</strong> | SAMPLES: <strong>--</strong>
</div>

</div><!-- /app -->

<!-- COMPLETION BANNER -->
<div class="complete-overlay" id="complete-overlay">
    <div class="complete-banner">
        <h1>TRAINING COMPLETE</h1>
        <p id="complete-details">--</p>
    </div>
</div>

<script>
// =========================================================================
// MUD-PUPPY TRAINING DASHBOARD
// Tempest Vector-Neon -- Vanilla JS, zero dependencies
// =========================================================================

(function() {
'use strict';

// ---- Color constants ----------------------------------------------------
const C = {
    bg:      '#0a0e1a',
    panelBg: '#0d1420',
    grid:    '#1a2a3a',
    border:  '#1a3a4a',
    green:   '#39ff14',
    cyan:    '#00ffff',
    amber:   '#ffd700',
    magenta: '#ff00ff',
    red:     '#ff3333',
    text:    '#e0e0e0',
    dim:     '#607080',
};

// ---- Utility ------------------------------------------------------------

function fmt(n, decimals) {
    if (n == null || isNaN(n)) return '--';
    if (decimals !== undefined) return n.toFixed(decimals);
    if (Math.abs(n) < 0.001 && n !== 0) return n.toExponential(1).toUpperCase();
    if (Math.abs(n) >= 1000) return n.toLocaleString('en-US', {maximumFractionDigits: 0});
    if (Math.abs(n) >= 10) return n.toFixed(1);
    return n.toFixed(3);
}

function fmtTime(seconds) {
    if (seconds == null || isNaN(seconds) || seconds <= 0) return '--:--';
    var h = Math.floor(seconds / 3600);
    var m = Math.floor((seconds % 3600) / 60);
    var s = Math.floor(seconds % 60);
    if (h > 0) return h + ':' + String(m).padStart(2,'0') + ':' + String(s).padStart(2,'0');
    return m + ':' + String(s).padStart(2,'0');
}

function fmtLR(v) {
    if (v == null || isNaN(v)) return '--';
    return v.toExponential(1).toUpperCase();
}

function fmtEpoch(epoch, maxEpochs) {
    if (epoch == null || isNaN(epoch)) return '--';
    var ep = epoch.toFixed(1);
    if (maxEpochs != null && maxEpochs > 0) return ep + '/' + maxEpochs;
    return ep;
}

// ---- DPR-aware canvas sizing -------------------------------------------
function setupCanvas(canvas) {
    var dpr = window.devicePixelRatio || 1;
    var rect = canvas.getBoundingClientRect();
    var w = Math.floor(rect.width);
    var h = Math.floor(rect.height);
    if (w === 0 || h === 0) return { w: 0, h: 0, dpr: dpr };
    canvas.width = w * dpr;
    canvas.height = h * dpr;
    var ctx = canvas.getContext('2d');
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    return { w: w, h: h, dpr: dpr };
}

// =========================================================================
// Chart class -- rolling line chart with neon glow
// =========================================================================

function Chart(canvasId, color, label, maxPoints) {
    this.canvas = document.getElementById(canvasId);
    this.ctx = this.canvas.getContext('2d');
    this.color = color;
    this.label = label;
    this.maxPoints = maxPoints || 500;
    this.data = [];
    this._w = 0;
    this._h = 0;
    this._dirty = true;
    this._awId = 'aw-' + canvasId.replace('chart-', '');
    this._setupResize();
}

Chart.prototype._setupResize = function() {
    var self = this;
    var ro = new ResizeObserver(function() {
        self._dirty = true;
    });
    ro.observe(this.canvas.parentElement);
};

Chart.prototype.push = function(value) {
    this.data.push(value);
    if (this.data.length > this.maxPoints) {
        this.data.shift();
    }
    this._dirty = true;
    // hide awaiting placeholder
    var aw = document.getElementById(this._awId);
    if (aw) aw.style.display = 'none';
};

Chart.prototype.render = function() {
    if (!this._dirty) return;
    this._dirty = false;

    var s = setupCanvas(this.canvas);
    if (s.w === 0) return;
    this._w = s.w;
    this._h = s.h;
    var ctx = this.ctx;
    var w = s.w, h = s.h;
    var pad = { l: 52, r: 8, t: 8, b: 20 };
    var cw = w - pad.l - pad.r;
    var ch = h - pad.t - pad.b;

    // clear
    ctx.clearRect(0, 0, w, h);

    // grid
    ctx.strokeStyle = C.grid;
    ctx.lineWidth = 0.5;
    var gridRows = 4;
    for (var i = 0; i <= gridRows; i++) {
        var gy = pad.t + (ch / gridRows) * i;
        ctx.beginPath();
        ctx.moveTo(pad.l, gy);
        ctx.lineTo(w - pad.r, gy);
        ctx.stroke();
    }
    var gridCols = 6;
    for (var j = 0; j <= gridCols; j++) {
        var gx = pad.l + (cw / gridCols) * j;
        ctx.beginPath();
        ctx.moveTo(gx, pad.t);
        ctx.lineTo(gx, h - pad.b);
        ctx.stroke();
    }

    if (this.data.length < 2) return;

    // compute range
    var minV = Infinity, maxV = -Infinity;
    for (var k = 0; k < this.data.length; k++) {
        var v = this.data[k];
        if (v < minV) minV = v;
        if (v > maxV) maxV = v;
    }
    if (minV === maxV) { minV -= 0.1; maxV += 0.1; }
    var range = maxV - minV;
    var margin = range * 0.08;
    minV -= margin;
    maxV += margin;
    range = maxV - minV;

    // axis labels
    ctx.fillStyle = C.dim;
    ctx.font = '10px "Share Tech Mono", monospace';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    ctx.fillText(fmt(maxV), pad.l - 4, pad.t + 4);
    ctx.fillText(fmt(minV), pad.l - 4, h - pad.b - 2);

    // trace with glow
    ctx.save();
    ctx.shadowBlur = 8;
    ctx.shadowColor = this.color;
    ctx.strokeStyle = this.color;
    ctx.lineWidth = 1.5;
    ctx.lineJoin = 'round';
    ctx.beginPath();
    var n = this.data.length;
    for (var di = 0; di < n; di++) {
        var x = pad.l + (di / (n - 1)) * cw;
        var y = pad.t + ch - ((this.data[di] - minV) / range) * ch;
        if (di === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.restore();

    // fill under curve
    ctx.save();
    ctx.globalAlpha = 0.05;
    ctx.fillStyle = this.color;
    ctx.beginPath();
    for (var fi = 0; fi < n; fi++) {
        var fx = pad.l + (fi / (n - 1)) * cw;
        var fy = pad.t + ch - ((this.data[fi] - minV) / range) * ch;
        if (fi === 0) ctx.moveTo(fx, fy);
        else ctx.lineTo(fx, fy);
    }
    ctx.lineTo(pad.l + cw, pad.t + ch);
    ctx.lineTo(pad.l, pad.t + ch);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
};


// =========================================================================
// ArcGauge class
// =========================================================================

function ArcGauge(canvasId, label, maxValue, unit, thresholdPct) {
    this.canvas = document.getElementById(canvasId);
    this.ctx = this.canvas.getContext('2d');
    this.label = label;
    this.maxValue = maxValue || 100;
    this.unit = unit || '';
    this.value = 0;
    this.thresholdPct = thresholdPct || 0.85;
    this._dirty = true;
    this._setupResize();
}

ArcGauge.prototype._setupResize = function() {
    var self = this;
    var ro = new ResizeObserver(function() { self._dirty = true; });
    ro.observe(this.canvas.parentElement || this.canvas);
};

ArcGauge.prototype.setValue = function(v) {
    this.value = v;
    this._dirty = true;
};

ArcGauge.prototype.render = function() {
    if (!this._dirty) return;
    this._dirty = false;

    var s = setupCanvas(this.canvas);
    if (s.w === 0) return;
    var ctx = this.ctx;
    var w = s.w, h = s.h;

    ctx.clearRect(0, 0, w, h);

    var cx = w / 2;
    var cy = h * 0.55;
    var r = Math.min(cx - 8, cy - 4) * 0.85;
    var startA = 0.75 * Math.PI;
    var endA = 2.25 * Math.PI;
    var sweep = endA - startA;
    var pct = Math.min(this.value / this.maxValue, 1);
    var fillA = startA + sweep * pct;

    // track
    ctx.beginPath();
    ctx.arc(cx, cy, r, startA, endA);
    ctx.strokeStyle = C.grid;
    ctx.lineWidth = 6;
    ctx.lineCap = 'butt';
    ctx.stroke();

    // fill arc
    if (pct > 0) {
        var grad = ctx.createLinearGradient(cx - r, cy, cx + r, cy);
        grad.addColorStop(0, C.cyan);
        grad.addColorStop(this.thresholdPct, C.amber);
        grad.addColorStop(1, C.red);
        ctx.beginPath();
        ctx.arc(cx, cy, r, startA, fillA);
        ctx.strokeStyle = grad;
        ctx.lineWidth = 6;
        ctx.lineCap = 'butt';
        ctx.save();
        ctx.shadowBlur = 8;
        ctx.shadowColor = pct > this.thresholdPct ? C.red : C.cyan;
        ctx.stroke();
        ctx.restore();
    }

    // center value
    ctx.fillStyle = C.text;
    ctx.font = '16px "Share Tech Mono", monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(fmt(this.value, 1) + this.unit, cx, cy);
};


// =========================================================================
// Sparkline (for throughput)
// =========================================================================

function Sparkline(canvasId, color, maxPoints) {
    this.canvas = document.getElementById(canvasId);
    this.ctx = this.canvas.getContext('2d');
    this.color = color;
    this.maxPoints = maxPoints || 120;
    this.data = [];
    this._dirty = true;
    var self = this;
    new ResizeObserver(function() { self._dirty = true; }).observe(this.canvas.parentElement);
}

Sparkline.prototype.push = function(v) {
    this.data.push(v);
    if (this.data.length > this.maxPoints) this.data.shift();
    this._dirty = true;
};

Sparkline.prototype.render = function() {
    if (!this._dirty) return;
    this._dirty = false;
    var s = setupCanvas(this.canvas);
    if (s.w === 0) return;
    var ctx = this.ctx;
    var w = s.w, h = s.h;
    ctx.clearRect(0, 0, w, h);

    if (this.data.length < 2) return;

    var minV = Infinity, maxV = -Infinity;
    for (var i = 0; i < this.data.length; i++) {
        if (this.data[i] < minV) minV = this.data[i];
        if (this.data[i] > maxV) maxV = this.data[i];
    }
    if (minV === maxV) { minV -= 1; maxV += 1; }
    var range = maxV - minV;
    var pad = 2;
    var cw = w - pad * 2;
    var ch = h - pad * 2;
    var n = this.data.length;

    ctx.save();
    ctx.shadowBlur = 6;
    ctx.shadowColor = this.color;
    ctx.strokeStyle = this.color;
    ctx.lineWidth = 1.5;
    ctx.lineJoin = 'round';
    ctx.beginPath();
    for (var j = 0; j < n; j++) {
        var x = pad + (j / (n - 1)) * cw;
        var y = pad + ch - ((this.data[j] - minV) / range) * ch;
        if (j === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.restore();
};


// =========================================================================
// LoRA Norms multi-line chart
// =========================================================================

function LoraNormChart(canvasId) {
    this.canvas = document.getElementById(canvasId);
    this.ctx = this.canvas.getContext('2d');
    this.layers = {};  // key -> [{step, val}]
    this.maxPoints = 200;
    this._dirty = true;
    this._colors = [C.cyan, C.green, C.amber, C.magenta, C.red, '#7744ff', '#ff8844', '#44ffaa'];
    var self = this;
    new ResizeObserver(function() { self._dirty = true; }).observe(this.canvas.parentElement);
}

LoraNormChart.prototype.update = function(data) {
    // data.layers = { "layers.0": {A: 0.12, B: 0.08}, ... }
    // or data.norms = { "model.layers.0.lora_A": 0.12, ... }
    var step = data.step || 0;
    var norms = data.layers || data.norms || {};
    var layerMap = {};

    // Normalize: collapse to per-layer aggregate
    for (var key in norms) {
        var val = norms[key];
        var layerName;
        if (typeof val === 'object') {
            // nested: {A: ..., B: ...} - average them
            var sum = 0, cnt = 0;
            for (var sub in val) { sum += val[sub]; cnt++; }
            layerName = key;
            layerMap[layerName] = cnt > 0 ? sum / cnt : 0;
        } else {
            // flat: extract layer name
            var m = key.match(/layers?[._](\d+)/);
            layerName = m ? 'L' + m[1] : key;
            if (!layerMap[layerName]) layerMap[layerName] = 0;
            layerMap[layerName] += parseFloat(val) || 0;
        }
    }

    for (var ln in layerMap) {
        if (!this.layers[ln]) this.layers[ln] = [];
        this.layers[ln].push({ step: step, val: layerMap[ln] });
        if (this.layers[ln].length > this.maxPoints) this.layers[ln].shift();
    }

    this._dirty = true;
    var aw = document.getElementById('aw-lora');
    if (aw) aw.style.display = 'none';
};

LoraNormChart.prototype.render = function() {
    if (!this._dirty) return;
    this._dirty = false;
    var s = setupCanvas(this.canvas);
    if (s.w === 0) return;
    var ctx = this.ctx;
    var w = s.w, h = s.h;
    ctx.clearRect(0, 0, w, h);

    var keys = Object.keys(this.layers);
    if (keys.length === 0) return;

    // global min/max
    var minV = Infinity, maxV = -Infinity;
    for (var ki = 0; ki < keys.length; ki++) {
        var arr = this.layers[keys[ki]];
        for (var ai = 0; ai < arr.length; ai++) {
            if (arr[ai].val < minV) minV = arr[ai].val;
            if (arr[ai].val > maxV) maxV = arr[ai].val;
        }
    }
    if (minV === maxV) { minV -= 0.01; maxV += 0.01; }
    var range = maxV - minV;
    var pad = { l: 6, r: 6, t: 4, b: 4 };
    var cw = w - pad.l - pad.r;
    var ch = h - pad.t - pad.b;

    // draw each layer
    for (var li = 0; li < keys.length; li++) {
        var pts = this.layers[keys[li]];
        if (pts.length < 2) continue;
        var color = this._colors[li % this._colors.length];
        ctx.save();
        ctx.shadowBlur = 4;
        ctx.shadowColor = color;
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        for (var pi = 0; pi < pts.length; pi++) {
            var x = pad.l + (pi / (pts.length - 1)) * cw;
            var y = pad.t + ch - ((pts[pi].val - minV) / range) * ch;
            if (pi === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
        ctx.restore();
    }
};


// =========================================================================
// Dashboard State & Instances
// =========================================================================

var lossChart = new Chart('chart-loss', C.green, 'LOSS', 500);
var lrChart   = new Chart('chart-lr',   C.cyan,  'LR',   500);
var gradChart = new Chart('chart-grad', C.amber, 'GRAD', 500);
var evalChart = new Chart('chart-eval', C.magenta, 'EVAL', 200);

var tpsSparkline = new Sparkline('chart-tps', C.green, 120);
var loraNorms = new LoraNormChart('chart-lora');

var vramGauge  = new ArcGauge('gauge-vram',  'VRAM',  24,  'GB', 0.85);
var utilGauge  = new ArcGauge('gauge-util',  'UTIL',  100, '%',  0.85);
var tempGauge  = new ArcGauge('gauge-temp',  'TEMP',  110, 'C',  0.75);
var powerGauge = new ArcGauge('gauge-power', 'POWER', 400, 'W',  0.80);

var state = {
    prevLoss: null,
    maxEpochs: null,
    connected: false,
};

// =========================================================================
// Message Handlers
// =========================================================================

function onMessage(msg) {
    var d = msg.data || msg;
    switch (msg.type) {
        case 'config':
            updateHeader(d);
            updateFooter(d);
            break;
        case 'metrics':
            updateStats(d);
            pushCharts(d);
            break;
        case 'gpu':
            updateGauges(d);
            break;
        case 'eval':
            if (d.eval_loss != null) evalChart.push(d.eval_loss);
            break;
        case 'lora_norms':
            loraNorms.update(d);
            break;
        case 'tokens':
            updateTokenStats(d);
            break;
        case 'complete':
            showCompleteBanner(d);
            break;
    }
}

function updateHeader(d) {
    var method = d.method || '--';
    var model = d.model || '--';
    document.getElementById('hd-method').textContent = method.toUpperCase();
    document.getElementById('hd-model').textContent = model;
    if (d.num_train_epochs) state.maxEpochs = d.num_train_epochs;
}

function updateFooter(d) {
    var model = d.model || '--';
    var method = d.method || '--';
    var prec = '';
    if (d.quant_backend) prec += d.quant_backend.toUpperCase() + ' ';
    if (d.precision) prec += d.precision.toUpperCase();
    if (!prec) prec = '--';
    var samples = d.dataset_size != null ? d.dataset_size.toLocaleString() : '--';
    var loraStr = '';
    if (d.lora_r != null) loraStr = ' | LORA R=' + d.lora_r + ' A=' + (d.lora_alpha || '--');

    document.getElementById('footer').innerHTML =
        'MODEL: <strong>' + model + '</strong>' +
        ' | METHOD: <strong>' + method.toUpperCase() + '</strong>' +
        loraStr +
        ' | PRECISION: <strong>' + prec + '</strong>' +
        ' | SAMPLES: <strong>' + samples + '</strong>';
}

function updateStats(d) {
    var step = d.step;
    var maxSteps = d.max_steps;
    var stepStr = fmt(step, 0);
    if (maxSteps) stepStr += '/' + fmt(maxSteps, 0);
    document.getElementById('st-step').textContent = stepStr;

    document.getElementById('st-epoch').textContent = fmtEpoch(d.epoch, state.maxEpochs);

    var lossEl = document.getElementById('st-loss');
    var loss = d.loss;
    lossEl.textContent = loss != null ? fmt(loss) : '--';
    // pulse on change
    if (state.prevLoss != null && loss != null) {
        lossEl.className = 'stat-value ' + (loss < state.prevLoss ? 'loss-down' : loss > state.prevLoss ? 'loss-up' : '');
    }
    state.prevLoss = loss;

    document.getElementById('st-lr').textContent = d.learning_rate != null ? fmtLR(d.learning_rate) : (d.lr != null ? fmtLR(d.lr) : '--');
    document.getElementById('st-grad').textContent = d.grad_norm != null ? fmt(d.grad_norm) : '--';
    document.getElementById('st-eta').textContent = fmtTime(d.eta_seconds);

    // token throughput from steps_per_sec
    if (d.steps_per_sec != null && d.steps_per_sec > 0) {
        tpsSparkline.push(d.steps_per_sec);
        document.getElementById('ts-tps').textContent = fmt(d.steps_per_sec, 1);
    }
}

function pushCharts(d) {
    if (d.loss != null) lossChart.push(d.loss);
    if (d.learning_rate != null) lrChart.push(d.learning_rate);
    else if (d.lr != null) lrChart.push(d.lr);
    if (d.grad_norm != null) gradChart.push(d.grad_norm);
}

function updateGauges(d) {
    var vramUsed = d.vram_used || 0;
    var vramTotal = d.vram_total || 24;
    vramGauge.maxValue = vramTotal;
    vramGauge.setValue(vramUsed);
    document.getElementById('gv-vram').textContent = fmt(vramUsed, 1) + ' / ' + fmt(vramTotal, 1) + ' GB';

    utilGauge.setValue(d.gpu_util || 0);
    document.getElementById('gv-util').textContent = fmt(d.gpu_util || 0, 0) + '%';

    tempGauge.setValue(d.temperature || 0);
    document.getElementById('gv-temp').textContent = fmt(d.temperature || 0, 0) + 'C';

    powerGauge.setValue(d.power_draw || 0);
    document.getElementById('gv-power').textContent = fmt(d.power_draw || 0, 0) + 'W';
}

function updateTokenStats(d) {
    if (d.tokens_per_sec != null) {
        tpsSparkline.push(d.tokens_per_sec);
        document.getElementById('ts-tps').textContent = fmt(d.tokens_per_sec, 1);
    }
    if (d.padding_pct != null) {
        document.getElementById('ts-pad').textContent = fmt(d.padding_pct, 0) + '%';
    }
    if (d.seq_length != null) {
        document.getElementById('ts-seq').textContent = fmt(d.seq_length, 0);
    }
}

function showCompleteBanner(d) {
    var time = fmtTime(d.total_time);
    var loss = d.best_loss != null ? fmt(d.best_loss) : '--';
    var steps = d.total_steps != null ? fmt(d.total_steps, 0) : '--';
    document.getElementById('complete-details').textContent =
        'TIME: ' + time + '  |  BEST LOSS: ' + loss + '  |  STEPS: ' + steps;
    document.getElementById('complete-overlay').classList.add('visible');
}


// =========================================================================
// Render Loop
// =========================================================================

function renderAll() {
    lossChart.render();
    lrChart.render();
    gradChart.render();
    evalChart.render();
    tpsSparkline.render();
    loraNorms.render();
    vramGauge.render();
    utilGauge.render();
    tempGauge.render();
    powerGauge.render();
    requestAnimationFrame(renderAll);
}
requestAnimationFrame(renderAll);


// =========================================================================
// WebSocket Connection
// =========================================================================

var wsAttempts = 0;
var ws = null;
var dot = document.getElementById('status-dot');

function connect() {
    var proto = location.protocol === 'https:' ? 'wss' : 'ws';
    var url = proto + '://' + location.host + '/ws';

    dot.className = 'status-dot reconnecting';

    try {
        ws = new WebSocket(url);
    } catch(e) {
        scheduleReconnect();
        return;
    }

    ws.onopen = function() {
        wsAttempts = 0;
        state.connected = true;
        dot.className = 'status-dot connected';
    };

    ws.onmessage = function(evt) {
        try {
            var msg = JSON.parse(evt.data);
            onMessage(msg);
        } catch(e) {
            // ignore malformed
        }
    };

    ws.onclose = function() {
        state.connected = false;
        dot.className = 'status-dot';
        scheduleReconnect();
    };

    ws.onerror = function() {
        // onclose will fire after this
    };
}

function scheduleReconnect() {
    wsAttempts++;
    var delay = Math.min(1000 * Math.pow(2, wsAttempts), 30000);
    dot.className = 'status-dot reconnecting';
    setTimeout(connect, delay);
}

connect();

})();
</script>
</body>
</html>
